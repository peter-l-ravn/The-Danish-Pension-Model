import numpy as np
from scipy.optimize import minimize
from consav.linear_interp import interp_1d, interp_2d, interp_3d, interp_4d
import matplotlib.pyplot as plt
from optimizer import optimizer

T = 4

X = 0.5
psi = 0.9
beta = 0.96

h_max = 1

N_a = 200
N_a_max = 4
a_grid = np.arange(0, N_a + 1) / (N_a / N_a_max)
m_grid = np.arange(0, N_a + 1) / (N_a / (N_a_max + h_max + X))

shape = (T, N_a + 1)

sol_V_work = np.full(shape, np.nan)
sol_h_work = np.full(shape, np.nan)
sol_c_work = np.full(shape, np.nan)

sol_V_notwork = np.full(shape, np.nan)
sol_h_notwork = np.full(shape, np.nan)
sol_c_notwork = np.full(shape, np.nan)

c_given_m = np.full(shape, np.nan)

def scalar(x):
    return x[0] if np.ndim(x) > 0 else x

def value_function_last_period(h, a, t):
    h = scalar(h)
    a = scalar(a)

    c = h + a + B(h, t)

    if c <= 0:
        c = 0.0
    
    return - (np.log(c+1e-5) - (h**2)/2)


def value_function_inner(c, h, sol_V_work, sol_V_notwork, a, t):
    c = scalar(c)
    h = scalar(h)

    m = h + a + B(h, t)
    a_next = m - c

    sol_V_next = max(interp_1d(a_grid, sol_V_work[t+1, :], a_next), 
                     interp_1d(a_grid, sol_V_notwork[t+1, :], a_next))

    return - (np.log(c+1e-5) - (h**2)/2 + beta*sol_V_next)


def value_function_given_m(c, sol_V_work, sol_V_notwork, m, t):
    c = scalar(c)

    a_next = m - c

    sol_V_next = max(interp_1d(a_grid, sol_V_work[t+1, :], a_next), 
                     interp_1d(a_grid, sol_V_notwork[t+1, :], a_next))

    return - (np.log(c+1e-5) + beta*sol_V_next)


def value_function_outer(h, c_given_m, sol_V_work, sol_V_notwork, a, t):
    a = scalar(a)
    h = scalar(h)

    m = h + a + B(h, t)

    c_star = interp_1d(m_grid, c_given_m[t, :], m)

    v_star = value_function_inner(c_star, h, sol_V_work, sol_V_notwork, a, t)

    return v_star


def B(h, t):
    h = scalar(h)
    if t < 2:
        return X if h == 0.0 else 0.0
        
    else:
        return (1-psi*h)*X
    

for t in range(T - 1, -1, -1):
    
    for m_idx, m in enumerate(m_grid):
        if t != T-1:
            c_given_m[t, m_idx] = optimizer(
                        value_function_given_m,
                        a=1e-8,
                        b=(m + 1e-6),
                        args=(sol_V_work, sol_V_notwork, m, t)
            )

    for a_idx, a in enumerate(a_grid):
        
        if t == T-1:

            sol_h_work[t, a_idx] = optimizer(
                        value_function_last_period,
                        a=0.1,
                        b=1,
                        args=(a,t)
            )
            
            sol_V_work[t, a_idx] = - value_function_last_period(sol_h_work[t, a_idx], a, t)
            sol_c_work[t, a_idx] = sol_h_work[t, a_idx] + a + B(sol_h_work[t, a_idx], t)


            sol_h_notwork[t, a_idx] = 0.0
            sol_V_notwork[t, a_idx] = - value_function_last_period(sol_h_notwork[t, a_idx], a, t)
            sol_c_notwork[t, a_idx] = a + B(sol_h_notwork[t, a_idx], t) 


        else:

            sol_h_work[t, a_idx] = optimizer(value_function_outer,
                                    a=0.1,
                                    b=1,
                                    args=(c_given_m, sol_V_work, sol_V_notwork, a, t)
            )
            
            sol_V_work[t, a_idx] = - value_function_outer(sol_h_work[t, a_idx], c_given_m, sol_V_work, sol_V_notwork, a, t)
            m = sol_h_work[t, a_idx] + a + B(sol_h_work[t, a_idx], t)
            sol_c_work[t, a_idx] = interp_1d(m_grid, c_given_m[t, :], m)


            sol_h_notwork[t, a_idx] = 0.0
            sol_V_notwork[t, a_idx] = - value_function_outer(sol_h_notwork[t, a_idx], c_given_m, sol_V_work, sol_V_notwork, a, t)
            m = a + B(sol_h_notwork[t, a_idx], t)
            sol_c_notwork[t, a_idx] = interp_1d(m_grid, c_given_m[t, :], m)
